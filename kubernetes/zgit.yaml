apiVersion: v1
kind: Secret
metadata:
  name: github-creds
# type: Opaque
type: kubernetes.io/basic-auth
stringData:
  username: Oyelowo
  password: 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
---
# This example demonstrates the use of a git repo as a hard-wired input artifact.
# The argo repo is cloned to its target destination at '/src' for the main container to consume.
apiVersion: argoproj.io/v1alpha1
kind: Workflow
metadata:
    generateName: monster-stack-git-
spec:
    entrypoint: git-clone
    templates:
        - name: git-clone
          inputs:
              artifacts:
                  - name: argo-source
                    path: /src
                    git:
                        repo: https://github.com/Oyelowo/modern-distributed-app-template.git
                        # repo: https://github.com/Oyelowo/oyelowo.git
                        # revision: 'v2.1.1'
                        # For private repositories, create a k8s secret containing the git credentials and
                        # reference the secret keys in the secret selectors: usernameSecret, passwordSecret,
                        # or sshPrivateKeySecret.
                        # NOTE: when authenticating via sshPrivateKeySecret, the repo URL should supplied in its
                        # SSH format (e.g. git@github.com:argoproj/argo-workflows.git). Similarly, when authenticating via
                        # basic auth, the URL should be in its HTTP form (e.g. https://github.com/argoproj/argo-workflows.git)
                        usernameSecret:
                          name: github-creds
                          key: username
                        passwordSecret:
                          name: github-creds
                          key: password
                        # sshPrivateKeySecret:
                        #   name: github-creds
                        #   key: ssh-private-key
                        #
                        # insecureIgnoreHostKey disables SSH strict host key checking during the git clone
                        # NOTE: this is unnecessary for the well-known public SSH keys from the major git
                        # providers (github, bitbucket, gitlab, azure) as these keys are already baked into
                        # the executor image which performs the clone.
                        # insecureIgnoreHostKey: true
                        #
                        # Shallow clones/fetches can be performed by providing a `depth`.
                        # depth: 1
                        #
                        # Additional ref specs to fetch down prior to checkout can be
                        # provided with `fetch`. This may be necessary if `revision` is a
                        # non-branch/-tag ref and thus not covered by git's default fetch.
                        # See https://git-scm.com/book/en/v2/Git-Internals-The-Refspec for
                        # the refspec format.
                        # fetch: refs/meta/*
                        # fetch: refs/changes/*
                        #
                        # Single branch mode can be specified by providing a `singleBranch` and `branch` This mode
                        # is faster than passing in a revision, as it will only fetch the references to the given branch.
                        # singleBranch: true
                        # branch: my-branch
          container:
              image: docker
              # command: [sh, -c]
              # args: ['ls -lart']
              command: [sh, -c]
              args: ['docker build -f ./Dockerfile.production --build-arg NEXT_PUBLIC_API_URL=oyelowo.ca --target web -t web']
              # args: ['make install; make test']
              # args: ['ls -lart']
              # args: ['cat README.md']
#               command: [python, -c]
# # fail with a 66% probability
# args: ['import random; import sys; exit_code = random.choice([0, 1, 1]); sys.exit(exit_code)']

              workingDir: /src/typescript

